[TOC]

# 面试题目

腾讯注重软件类课程的基本功，注重编程能力，注重基础知识。

美团注重基础，要求比较高，注重积累、学习经验、学习的时间，对项目的参与度。

网易注重CSS等布局语法细节，注重基础知识



## 特殊题目

### [] == false（[]转数值为0） 、 但是!![] == true（先转布尔，任何对象转布尔都是true，除了null）

### [] != []  、{}!={}，对象是不相等的（两个都是对象 比较是不是同一个对象）

### 闭包

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000*i);
} // 使其输出为0,1,2,3,4 但是输出了5,5,5,5,5
```

1. 把var换成let

2. 使用闭包

   ```javascript
   for (var i = 0; i < 5; i++) {
       (function(i) {
           setTimeout(function() {
               console.log(i);
           }, i * 1000);
       })(i);
   } // 0,1,2,3,4
   ```

   使用立即执行函数形成闭包，切断外部对i的引用

   - 不使用闭包：

     ```javascript
     for (var i = 0; i < 5; i++) {
         (function() {
             setTimeout(function() {
                 console.log(i);
             }, i * 1000);
         })(i);
     } // 5,5,5,5,5
     ```

     内部没有对i的引用，因此隔段时间输出5

   - 这样：

     ```javascript
     for (var i = 0; i < 5; i++) {
         setTimeout((function(i) {
             console.log(i);
         })(i), i*1000);
     }
     ```

     setTimeout的第一个参数只接受单句code或者函数，那么立即执行函数是undefined。因此setTimeout失效了，因此就立即执行函数，输出0-4

   - promise

     ```javascript
     setTimeout(function() {
       console.log(1)
     }, 0);
     new Promise(function executor(resolve) {
       console.log(2);
       for( var i=0 ; i<10000 ; i++ ) {
         i == 9999 && resolve();
       }
       console.log(3);
     }).then(function() {
       console.log(4);
     });
     console.log(5);
     ```

     首先碰到一个setTimeout，会设置一个定时，定时结束后放到任务队列里，故而刚开始不会输出1；promise里面的函数是直接执行的，故而输出`2, 3`，then会放到当前tick后，但还是在当前tick里面，故而先输出5，然后输出4，最后一个tick是1，故而最后输出`2, 3, 5, 4, 1`


## 基础知识

### 产生死锁的必要条件

- 互斥条件：进程对所分配的资源不允许其他进程访问
- 请求和保持条件： 进程获取其他资源，却被其他进程占用，但又对自己保持的资源不放手
- 不可剥夺：进程已经获得资源，除非自己使用完释放，否则不可被剥夺
- 循环等待：发生死锁之后，必然存在一个进程和资源之间的环形链

### DNS

DNS将域名解析为IP，有两种查询方式

1. 递归查询

   > 所谓递归查询就是：如果主机所询问的本机域名服务器不知道被查询的域名的IP地址，那么本机域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替主机继续查询），而不是让主机自己进行下一步查询。

   发送请求    本地域名服务器    根域名服务器    顶级域名服务器    主域名服务器 

2. 迭代查询

   > 迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器，“你下一步应当向哪一个域名服务器进行查询”，然后让本地域名服务器继续进行后续的查询

   发送请求    本地域名服务器

   发送请求    根域名服务器

   发送请求    顶级域名服务器

   发送请求    主域名服务器

3. DNS缓存

   - 浏览器缓存
   - 路由缓存
   - 根域名服务器缓存
   - 顶级域名服务器缓存
   - 主域名服务器缓存
   - 本地域名服务器缓存

### HTTPDNS

> 域名系统(DNS)：作为域名和IP地址相互映射的一个分布式数据库，通过DNS可以将域名解析为IP地址
>
> CDN(Connet Delivery Network)：其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定
>
> HTTPDNS：使用HTTP请求来模拟DNS请求
>
> DNS循环：当权威DNS发现一个域名映射多个IP时，会使用IP轮询的方式来将IP平均分配给多个DNS请求，从而达到负载均衡的效果

1. 概念：使用http协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求。将服务器返回的IP地址获取后，直接向该IP地址发起对应的API请求，代替使用域名

2. 为什么要使用HTTPDNS？

   - LocalDNS劫持

     由于HTTPDNS是通过直接请求HTTP获取服务器的IP地址，不存在向本地运营商访问域名的过程，从而避免了劫持

   - 平均访问延迟下降

     由于IP直接访问省去了一次域名解析的过程，通过智能算法排序后找到最快的节点进行访问

   - 用户连接失败率降低

     通过算法，降低以往失败率较高的服务器的排序，通过近期历史访问成果记录提高服务器排序，如果IP(a)访问错误，下次将返回IP(b)排序后的结果

### HTTP2.0和HTTP1.x的区别

#### 多路复用

HTTP2.0复用TCP连接。在一个TCP连接里，客户端和浏览器都可以同时发送多个请求和回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞“。每个请求/响应都使用不同的Stream ID，一个连接上可以有多个请求，每个连接的请求可以随机混杂在一起，接收方可以根据请求的ID将请求再归属到不同的服务端请求里

#### 流优先级

HTTP2.0支持浏览器指定资源的优先级

#### HEADER压缩传输

使用HPACK算法用做首部压缩

#### 二进制格式

使用二进制传送。

#### 数据流

HTTP2.0可以取消某一次请求（而HTTP1.1的方法就是关闭TCP连接），保持TCP连接打开，被其他请求使用。客户端和服务端都可以发送RST_STREAM帧，来取消这个数据流

#### 服务器推送

服务器把客户端需要的资源一起推送到客户端。例如服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML再发送这些请求。

1. 客户端可以设置SETTINGS_ENABLE_PUSH为0来通知服务端禁用推送
2. 发现缓存后，客户端和服务端都可以发送信号(RST_STREAM帧)，来取消这个数据流
3. cache-digest

### HTTP状态码

#### 1xx 可续发送请求

#### 2xx 成功

- 200 采用强缓存机制。
- 202 成功
- 204 成功 不返回实体请求
- 206 成功，执行一个范围请求

#### 3xx 重定向

- 301 永久重定向
- 302 临时重定向 禁止post变成get
- 303 临时重定向 使用get请求新的URL
- 304 采用协商缓存机制 
- 307 临时重定向

#### 4xx 客户端错误

- 400 客户端语法错误
- 401 未经授权
- 403 服务器拒绝服务
- 404 请求资源不存在

#### 5xx 服务器错误

- 500 不可预期的错误
- 503 此时不能提供服务，稍后恢复正常



### 浏览器缓存

####按缓存位置：Service Worker、Memory Cache、Disk Cache、网络请求

**Service Worker** 

本质上充当了Web应用程序和浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。

接口有Cache、Cache Storage等

**Memory Cache**

- 浏览器标签关闭后失效
- 保证了一个页面中如果有两个相同的资源，会只请求一次
- 匹配规则有URL、类型、CORS中的域名规则等

**Disk Cache（HTTP Cache）**

- 存储在硬盘上的缓存，是持久存储的，实际存在于文件系统中的。允许相同的资源在跨会话、甚至在跨站点的情况下使用，例如两个站点都使用了同一张图片
- 严格根据HTTP的头信息来判断哪些资源能否缓存、可用性等，命中缓存后，会从硬盘中读取资源
- 自动清理时，使用算法清理“最老的”或“最可能使用的”。各个浏览器的清理算法各不相同

**请求网络**

如果一个请求在上述三个位置都没有找到缓存，会发送网络请求去获取内容。之后为了提高缓存命中率，会把这个资源添加到缓存中。具体来说：

- 根据Service Worker中的handler决定是否存入Cache Storage
- 根据HTTP头部的相关字段决定是否存入Disk Cache
- Memory Cache保留一份资源的引用



#### 按失效策略：强缓存与协商缓存

> memory cache 是浏览器为了加快读取缓存速度而进行的自身的优化行为，不受开发者控制，也不受 HTTP 协议头的约束，算是一个黑盒。Service Worker 是由开发者编写的额外的脚本，且缓存位置独立，出现也较晚，使用还不算太广泛。所以我们平时最为熟悉的其实是 disk cache，也叫 HTTP cache (因为不像 memory cache，它遵守 HTTP 协议头中的字段)。平时所说的强制缓存，对比缓存，以及 Cache-Control 等，也都归于此类。

##### 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的

![ç¬¬ä¸æ¬¡åèµ·HTTPè¯·æ±](https://user-gold-cdn.xitu.io/2018/5/20/1637d0bbd695e751?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 为什么要引入ETag？
  - 为了解决Last-Modified无法解决的一些问题
    - 一些文件也许会周期性的更改，但是内容不改变（仅仅修改改变的时间），这时候我们不希望客户端认为这个文件被修改了从而重新请求
    - 某些文件的修改十分频繁，在s以下的时间粒度内修改
    - 某些服务器不能精确得到文件的最后修改时间

**cache-control**的取值：

**private**  客户端可以缓存

**public** 客户端和代理服务器（如CDN）都可以缓存

**max-age=xxx** 缓存的内容将在xxx秒后失效

**no-cache** 使用对比缓存来验证数据

**no-store** 所有内容都不会缓存，强制缓存、对比缓存都不会触发

**强缓存**

- 强缓存生效后，状态码为200

**对比缓存**

- 对比缓存生效时，状态码为304，说明资源无最新修改，浏览器使用缓存，状态码为200，说明资源被改动过，响应整片资源内容

- 报文大小和请求时间大大减少。这是因为服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体返回给客户端

- ETag优先级高于Last-Modified

- 请求头：If-None-Match 或 If-Modified-Since

  响应头：ETag 或 Last-Modified



浏览器第一次请求：

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142134291-1976923079.png)

浏览器再次请求时：

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)

##### 浏览器行为可能改变对资源的读取方式

> 当浏览器要请求资源时：
>
> 1. 调用Service Worker的fetch响应
> 2. 查看memory cache
> 3. 查看disk cache
>    - 如果有强缓存且未失效（max-age），则使用强制缓存，不发送请求，状态码是200
>    - 如果已经过期，使用对比缓存，发送IF-NONE-MATCH或IF-MODIFIED-SINCE，服务器比较之后发送ETAG或LAST-MODIFIED，状态码为304（只有头部）或200（资源改变，重新返回）
> 4. 发送网络请求，等待响应，约定缓存策略
> 5. 把响应内容存入DISK CACHE（如果HTTP头信息可以存，不为no-store）
> 6. 把响应内容的引用存入MEMORY CACHE
> 7. 把响应内容存入Service Worker的Cache Storage（如果可以）



如果资源已经被缓存，在缓存失效前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器可以从缓存中读取，否则从服务器返回最新的资源。

###### ctrl+f5强制刷新，则直接从服务器加载，跳过强缓存和协商缓存不使用缓存

###### f5刷新页面，会设置max-age=0，会跳过强缓存但是检查协商缓存

###### 地址栏访问，链接跳转，浏览器的刷新按钮是正常用户行为，先从Memory Cache里找，然后触发浏览器缓存机制从Disk Cache里查找



### TCP为什么是三次握手，可以两次吗



### 对网页性能的优化

1. 减少HTTP请求次数： 

   - CSS sprites
     - 即CSS精灵，将多张图片融合到一幅图里，通过CSS布局到网页上，可以减少图片数量，带来速度上的提升。
     - 合并后的图片比分离的图片总和要小
   - 使用字体图标代替大量图标的图片
   - 合并压缩脚本和样式表

2. 使用CDN托管网站静态资源

   - CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容
   - 在优化性能时，向特定的游湖发布内容的服务器的选择基于对网络拥堵的测量。
   - 例如CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器
   - 缺点：
     - 响应时间可能受到其他网站流量影响。CDN服务提供商在其所有客户之间共享Web服务器组
     - 如果CDN服务质量下降，工作质量也将下降
     - 无法直接控制组件服务器

3. 使用缓存

4. 服务器端使用gzip压缩内容

   - 从HTTP1.1开始，客户端可以发送Accept-Encoding:gzip,deflate请求头来表示对压缩的支持
   - 如果Web服务器看到这个请求头，就会使用客户端列出的一种方法来压缩。
   - 服务器通过Content-Encoding来通知Web客户端它选择的压缩方式

5. 避免空的src和href

6. 将CSS放到顶部

   - 这并不会降低实际页面加载时间，但是会减少页面首屏加载时间，使页面内容逐步呈现
   - 将样式表放在文档底部会阻止浏览器中的内容逐步出现，为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”

7. Js放到底部

   - js的下载和执行会阻塞DOM树的构建，所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容

8. 避免使用CSS表达式

9. 使用外部的CSS和js

   - 当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在之后加载的时候直接使用缓存
   - HTML文档的大小减小，提高了加载速度

10. 减少DNS查询

    - 将资源都放在一个域下面，这样访问整个网站只需要一次DNS查询，但是因为客户端针对每一个域有一定数量的并行度，那么就会出现下载资源时的排队现象。
    - 因此建议一个网站中至少使用2个域，但是不多于4个域来提供资源

11. 精简js

    - 精简

      从代码中移除不必要的字符以减少文件大小

    - 混淆

      移除注释和空白符，还会改写代码。把函数和变量名转换成更短的字符串

    - CSS的精简

      - 移除空白和注释
      - 合并相同的类
      - 移除不使用的类
      - 使用缩写

12. 避免重定向

13. 删除重复脚本

14. 配置ETag

15. 使Ajax可缓存

### MVC、MVC2、MVP和MVVM模式

### PWA



### 设计模式

### 在浏览器输入一个URL，会发生什么？

1. DNS解析
2. 客户端发送请求
   - TCP三次握手建立网络连接
   - 浏览器发送http请求
   - 网络IP协议查询MAC地址，将TCP分割好的数据包发送给接收方
   - 找到MAC地址，数据发送到链路层进行传输
3. 服务器响应
   - 服务器响应请求，返回http响应报文
   - 返回响应文件
4. 页面渲染
   - 解析HTML，生成DOM树（遇到外链则中断文档解析，下载并执行后，继续文档解析）
   - 解析CSS文件
   - 生成渲染树（受样式影响，不可见元素和display none都不在树中）
   - 绘制渲染树
5. 连接结束

### 重绘和重排

- 网页的生成过程

网页的生成过程大致可以分成五步：

1. HTML转化成DOM
2. CSS转化成CSSOM（CSS Object Model）
3. 结合DOM树和CSSOM，生成渲染树（包含每个节点的视觉信息）
4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成
5. 将布局绘制(paint)在屏幕上



其中4-5步是十分耗时的，生成布局（flow）和绘制（paint）这两步，合称为渲染（render）

- 重排：重新生成布局

- 重绘：重新绘制

- 重绘不一定需要重排，重排必然会导致重绘

- 任何改变用来构建渲染树的信息都会导致一次重排或重绘。

  - 添加、更新、删除DOM节点
  - 通过display:none隐藏一个DOM节点，触发重绘和重排
  - 通过visibility:hidden隐藏一个DOM节点，只触发重绘
  - 移动或者给页面中的DOM节点增加动画
  - 增加一个样式表
  - 用户行为  如调整窗口大小、改变字号、或者滚动

- 浏览器的应对

  - 浏览器基于脚本创建一个变化的队列，然后分批去展现，通过这种方式许多需要一次重排的变化就会整合起来，最终只有一次重排会被计算渲染

  - 有时候代码会组织浏览器优化重排并立即刷新队列，与此同时展示所有批次的变化，这通常发生在请求样式信息的时候。例如：

    - offsetTop、offsetLeft、offsetHeigt
    - scrollTop
    - clientTop
    - getComputedStyle currentStyle in IE

    为了提高最新的样式值，浏览器必须应用所有队列中的变更，刷新队列然后去实现重排

#### 最小化重绘和重排

- 不要逐个改变样式。对于静态文件来说，可以改类名或直接修改csstext
- 离线的批量改变和表现DOM。离线意味着不在当前的DOM树中做修改可以
  - 通过documentFragment来保留临时变动
  - 复制即将更新的节点，在副本上工作，然后交换节点
  - 通过display:none隐藏元素，添加足够多变更后，再改变display展示。这样只有两次重绘重排
  - 不要频繁计算样式
  - position为absolute或fixed的元素，重排的开销会比较小
  - 使用虚拟DOM的脚本库，如React

### W3C

为了解决网络应用中不同平台、技术、开发者带来的不兼容问题，万维网联盟制定了一系列标准来督促开发者遵循。标准的内容包括使用语言的规范、开发中使用的准则和解释引擎的行为。标签都成对出现、属性值都放到引号里。

### 前端安全性

#### CSRF（跨站请求伪造）：攻击者伪造成用户身份进行操作，服务器识别不了请求的合法性

- 攻击方式：在用户的session尚未到期时诱导用户打开恶意URL，从而伪造成用户的身份向服务器发送合法的请求

- 防御措施

  - 验证HTTP的Refer字段

  - 在请求地址增加token并验证

    在用户登录后放在session中，每次请求时把session的token与请求的token比对

  - 在HTTP头增加自定义属性并验证

#### XSS（跨站脚本攻击）：恶意攻击者往Web页面中插入恶意脚本，当用户浏览该页时嵌入其中的脚本会被执行，从而达到恶意攻击用户的目的

**反射型**：经过后端，不经过数据库。

```
http://www.test.com/message.php?send=Hello,World！

接收者将会接收信息并显示Hello,Word

非正常发送消息：

http://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！

接收者接收消息显示的时候将会弹出警告窗口
```



**存储型**：经过后端和数据库

**防御措施**：

- 编码 < > / ' " &
- 表单校验
- 对于重要的cookie设置http only，不允许在js中获取该cookie
- 过滤或移除特殊的html标签
- 过滤js事件的标签 例如 "onclick=", "onfocus" 等等



### 打包工具

#### Webpack

#### PosrCSS

#### eos

### HTML

####针对移动端浏览页面，需要全屏单页面，不希望用户放大屏幕

#### `data-xxx`属性的作用是？

#### cookies、sessionStorage、localStorage的区别？

| 特性           | cookies                                                      | sessionStorage                                              | localStorage             |
| -------------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------ |
| 数据的生命周期 | 一般由服务器生成，可以甚至生效时间。如果在浏览器端生成，默认浏览器关闭后失效 | 关闭页面后被清除                                            | 除非被清除，否则永久保存 |
| 存放数据大小   | 4k左右                                                       | 一般5M                                                      |                          |
| 与服务端通信   | 每次携带在HTTP头里                                           | 仅在浏览器保存                                              |                          |
| 易用性         | 需要程序员自己封装，原生的cookie接口不太友好                 | 原生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                          |

##### cookie： 每个http都携带cookie信息，可以判断用户是否登录。对于登录过的用户，服务器端在其登录时在cookie插入一段加密的唯一辨识单用户的标识码，下次读取这个值就可以判断用户是否登录

##### localStorage：用来保存电商网站的购物车信息，保存H5游戏产生的一些本地数据。存储一些固定不变的页面信息

##### sessionStorage：页面传值

#### HTTPONLY

IE6的SP1在cookie里引入了`http-only`，告知浏览器该cookie决不能通过js的API访问

#### 浏览器的标准模式和怪异模式

排版引擎有：标准模式、怪异模式、混杂模式



### CSS

#### 盒模型、边界塌陷、负值作用

1. 盒模型

   - ie678的怪异模式？使用IE盒模型（box-sizing:border-size）
   - Chrome ie9+ ie678（标准模式）使用标准盒模型（box-sizing:content-box）

2. 边距塌陷

   边距折叠发生在同一BFC的块级元素之间，上下边距是边距较大值而不是边距之和。

   会发生边距折叠的三种情况：

   - 相邻元素之间

     毗邻的两个元素之间的外边距会折叠（除非后一个元素需要[清除之前的浮动](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear)）。

   - 父元素与其第一个或最后一个子元素之间

     如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建[块格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)、或者[清除浮动](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear)将两者的 [`margin-top`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top) 分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、[`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height)、[`min-height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height)、[`max-height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-height)将两者的 [`margin-bottom`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom) 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。

   - 空的块级元素

     如果一个块级元素中不包含任何内容，并且在其 [`margin-top`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top) 与 [`margin-bottom`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom) 之间没有边框、内边距、行内内容、[`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height)、[`min-height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height) 将两者分开，则该元素的上下外边距会折叠。

3. 负值作用

4. https://juejin.im/post/5aad40e4f265da237f1e12ed

#### BFC

- 创建格式化上下文方式
  - 根元素或包括根元素的元素
  - 浮动元素 float不为none
  - 绝对定位 position为fixed或absolute
  - 行内块元素 display为inline-block
  - 表格单元格 display为table-cell 表格单元格默认
  - 表格标题 display为table-caption
  - 匿名表格单元格 display为table、table-row等
  - overflow不为visible
  - display为flow-root
  - contain为layout content strict
  - 弹性元素 flex inline-flex
  - 网格元素 grid inline-grid
  - 多列元素 
- BFC的作用
  - 清除内部浮动：对子元素设置浮动后，父元素的高度塌陷为0.为了解决这个问题，可以把父元素的高度设置为0
  - 解决边距重叠：相邻的盒子的外边距会重叠，可以把这两个盒子都变成BFC
  - 创建自适应两栏布局：

#### 垂直居中

###### 单行文本，height和line-height设置同一高度

###### 子元素定高：position:absolute top:50% margin:-高度的一半

###### 子元素不定高：position:absolute top:50% translation:(0, -50%)

###### display: table-cell; vertial-align: center

###### 父元素不设置高度，设置padding

###### 弹性布局：display:flex;align-items:center


#### CSS实现自适应正方形、三角形

#### 文字截断

##### 单行文本截断 text-overflow

```css
div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

### JS

#### 基本数据类型

undifined null boolean string number Object



#### arguments是什么？是数组吗？

```js
function a() {
    console.log(arguments); // { '0': 1, '1': 2, '2': 3 }
    var args = Array.prototype.slice.call(arguments);
    console.log(args); // [ 1, 2, 3 ]
}
a(1,2,3);
```





#### instanceof的原理

instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。

#### js的typeof

- undifined boolean number string function object


#### 如何区别{}和[]

- Array.isArray
- typeof a === 'object' && length
- Object.prototype.toString.call([]) === '[object Array]' Object.prototype.toString.call({}) === '[object Object]'
- instanceof Array
- constructor

#### call apply bind

1. call和apply就是改变this的值，区别在于传参的方法

   ```Js
   // apply以数组传入arguments
   function apply1(num1, num2) {
       return sum.apply(this, [num1, num2]);
   }
   // call以多参数的传入arguments
   function call1(num1, num2) {
       return sum.apply(this, num1, num2);
   }
   ```

2. bind后函数不会执行，只是返回一个改变了上下文的函数副本，而call和apply是直接执行函数

   ```Js
   var button = document.getElementById('button'),
       text = document.getElementById('text');
   
   button.onclick = function() {
       alert(this.text); // alert "text"
   }.bind(text);
   ```

   【问题】ie678不支持bind，如何模拟bind？

   ```Js
   if (!function() {}.bind) {
       Function.prototype.bind = function(context) {
           var self = this, // this指向调用它的对象，而非prototype
               args = Array.prototype.slice(arguments);
           return function() {
               return self.apply(context, args.slice(1));
           }
       }
   }
   ```

#### 原型链、对象、构造函数

1. 构造函数用来构造函数时初始化对象

2. 原型：

   - `__proto__`指向构造函数的prototype，`__proto__`连接存在于实例与构造函数的原型对象之间

     **new做的事情**

     ```js
     var obj = {};
     obj.__proto__=Base.prototype;
     Base.call(obj);
     ```

3. 关系

   - 构造函数》》》prototype》》》原型对象
     - 所有原型对象包含一个constructor属性，constructor属性指向构造函数
     - 原型对象是构造函数的一个实例
   - 原型对象》》》constructor》》》构造函数
   - 构造函数》》》new》》》实例对象
   - 实例对象》》》`__proto__`》》》构造函数的原型对象》》》原型对象

4. 原型链

   每个对象都有自己的原型对象，原型对象本身也是对象，原型对象也有自己的原型对象，这样就形成了一个链式结构，叫做原型链

   例如：访问某个对象的属性，首先在对象本身找，若没有，去原型对象找，一直找到原型链的终点；如果是修改对象的属性，若这个实例化对象中有该属性，就修改，没有该属性，就添加这个属性


#### 继承

##### 原型链继承

每个构造函数都有一个原型对象，原型对象都包括一个指向构造函数的的指针，实例都包含一个指向构造函数的原型对象的指针。让原型对象等于另一个对象的实例

```javascript
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function () {
    return this.property;
}

function SubType() {
    this.subproperty = false;
}
SubType.prototype = new SuperType();
SubType.prototype.getSubvalue = function () {
    return this.subproperty;
}

var instance = new SubType();
console.log(instance.getSuperValue());// true
```

SubType的原型是SuperType的实例，拥有SuperType的实例拥有的全部属性和方法，内部有一个指针，指向了SuperType的原型。则instance指向SubType的原型，SubType的原型指向SuperType的原型。

问题：

1. 所有子类实例共享构造函数的原型，也就是一个父类实例，原型上包含引用类型的属性时，一个子类实例修改了原型，会影响其他实例
2. 创建子类实例时，不能向父类的构造函数传递参数。（没有办法在不影响所有实例的情况下，给父类的构造函数传递参数）

##### 构造函数继承

```javascript
function SuperType() {
    this.property = true;
}

function SubType() {
    // 继承了SuperType,优势是可以传参数
    SuperType.call(this);
}
```

问题：

1. 每个子类都调用父类的构造函数，则方法复用无从谈起
2. 父类的原型的方法，也对子类不可见



##### 组合继承

使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既能实现方法的复用，又保证每个实例都有它自己的属性

```javascript
function SuperType(name) {
    this.name = name;
    this.colors = ['red'];
}

SuperType.prototype.sayName = function () {
    console.log(this.name);
}

function SubType(name, age) {
    // 继承属性
    SuperType.call(this, name);
    this.age = age;
}
// 继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayage = function () {
    console.log(this.age);
}

var instance = new SubType();
console.log(instance.getSuperValue());// true
```



#### new

```js
var obj = {};
obj.__proto__=Base.prototype;
Base.call(obj);
```

#### 

#### 遍历对象属性和方法

> https://www.cnblogs.com/chenyablog/p/6477866.html

##### Object.keys()返回一个数组，包括对象自身的（不含继承）的所有可枚举属性（不包含Symbol属性）

返回一个数组，包括对象自身的（不含继承的所有可枚举属性）

##### for... in 自身的和继承的可枚举属性（不包括Symbol）迭代一个对象的可枚举属性(包括**原型链**上的可枚举属性，即自定义的属性)

迭代一个对象的可枚举属性(包括**原型链**上的可枚举属性，即自定义的属性)

**原型属性**不能用for-in枚举出来

```Js
// 遍历object
for (val in obj) {
    console.log(val); // name, age, id
    console.log(obj[val]); // Li, 22, 14353147
}

// 遍历string
String.prototype.foo = 'you';
var str = 'love';
for (idx in str) {
    console.log(str[idx]); // l  o  v  e  you 
}

// 遍历Array
Array.prototype.foo = 666;
var arr = [1, 2, 3];
for (idx in arr) {
    console.log(arr[idx]); // 1  2  3  666
}
```

##### for…of（es6）

```Js
for (entry of arr) {
    console.log(entry);
}
/*
	L
	O
	V
	E
*/
```

##### Object.getOwnPropertyNames(obj) 返回一个数组，包括对象自身（不含继承）的所有属性（包括不可枚举的而熟悉，不含Symbol属性）

```Js
Object.getOwnPropertyNames(obj) // ["name", "age", "id"]
Object.getOwnPropertyNames(arr) // ["0", "1", "2", "3", "length"]
```

#### 深拷贝和浅拷贝

- 存储方式

  **基本数据类型** 保存在 **栈内存，**形式如下：栈内存中分别存储着变量的标识符以及变量的值。 

  **引用类型** 保存在 **堆内存** 中**，** 栈内存存储的是变量的标识符以及对象在堆内存中的存储地址，当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从对应的堆内存中取得所需的数据。 

- 浅拷贝

基本数据类型(undefined null string number boolean)的复制，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上

引用数据类型(Object)将对象的指针存储在为新变量分配的空间中，两个变量指向同一个对象

- 深拷贝

```
function cloneDeep(source){    
  if(!source && typeof source !== 'object'){      
    throw new Error('error arguments', 'shallowClone');    
  }    
  var targetObj = Array.isArray(source) ? [] : {};    
  for(var keys in source){       
    if(source.hasOwnProperty(keys)){  
      // 对于引用数据类型，递归操作进行深拷贝  
      if(source[keys] && typeof source[keys] === 'object'){  
        targetObj[keys] = cloneDeep(source[keys]);        
      }else{            
        targetObj[keys] = source[keys];         
      }       
    }    
  }    
  return targetObj; 
}
```

- JS相关复制方法：

  1. Array

     | 方法            | 类别            | 描述                                                         |
     | --------------- | --------------- | ------------------------------------------------------------ |
     | filter          | 深拷贝 just一层 | 创建一个新数组，其包含通过所提供函数实现的测试的所有元素     |
     | concat          | 深拷贝 just一层 | 合并两个或多个数组 concat() 方法把合并的数组元素**浅拷贝**到一个新数组对象。且原始数组不会被修改。 |
     | pop             |                 | 改变原数组 删除最后一个元素                                  |
     | push            |                 | 改变原数组 增加一个元素                                      |
     | reverse         |                 | 改变原数组                                                   |
     | shift           |                 | 改变原数组 删除第一个元素                                    |
     | unshift         |                 | 改变原数组 从头插入                                          |
     | slice           | 深拷贝 just一层 | slice() 方法返回一个从开始到结束（**\*不包括结束***）选择的数组的一部分**浅拷贝**到一个新数组对象。且原始数组不会被修改。 |
     | sort            |                 | 改变原数组                                                   |
     | splice          |                 | 改变原数组                                                   |
     | [...arr]        | 深拷贝 just一层 |                                                              |
     | Array.from(arr) | 深拷贝 just一层 |                                                              |

     ```javascript
     var a = [[1,2,3],4,5];
     var b = a.splice();
     console.log(a === b);// true
     a[0][0] = 6;
     console.log(a===b); // true
     console.log(a[0] === b[0]); // false
     ```

  2. JSON

     JSON的stringify方法把对象转化成json字符串，parse方法把json字符串转化为js对象，可以实现深拷贝

     ```javascript
     var obj = {a: 1, b:2};
     var obj2 = JSON.parse(JSON.stringify(obj));
     ```

#### 数组去重的方法

###### 使用ES6的Set结构，自动处理NaN
```javascript
const dedupe = function (arr) {
    return Array.from(new Set(arr));
}
let arr = [NaN, 0, [0], [], '0', NaN, {}, ['q'], 'q']; 
console.log(dedupe(arr));
```

###### 使用indexOf和filter，需要特殊处理NaN
```javascript
function dedupeq(array) {
    var hasNaN = false;
    var res = array.filter(function(item, index, array){
        // 由于[NaN].indexOf(NaN) === -1
        // 因此对NaN特殊处理
        if (!hasNaN && item !== item) {
            hasNaN = true;
            return true;
        }
        return array.indexOf(item) === index;
    });
    return res;
}


var arr = [NaN, 0, [0], [], '0', NaN, {}, ['q'], 'q', null, {}, undefined]; 
console.log(dedupeq(arr));
// // [NaN, 0, [0], [], "0", {}, ['q'], "q", null, {}, undefined]
```

#### target和currentTarget

#### 事件委托的优缺点

##### 减少事件注册、节省内存

##### 简化DOM更新时，相应事件的更新（动态增加子节点的情况）

##### 不支持冒泡的事件不支持委托

##### 理论上委托导致频繁调用回调



#### setTimeout原理

因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在指定时间后把回调事件推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才执行定时器的代码。 所以即使把定时器的时间设置为0还是会先执行当前的一些代码。

#### js的事件循环



#### 箭头函数

1. this对象是定义时确定的，而不是使用时确定的
2. 不能当构造函数 不能使用new 命令
3. 不能使用arguments对象
4. 