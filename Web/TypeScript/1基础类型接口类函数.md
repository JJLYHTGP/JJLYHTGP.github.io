# 1基础类型接口类函数

## 上手

[5分钟上手TypeScript](https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html)

- 类型注解：设置object报错？

## 实例学习

[TypeScriptSamples](https://github.com/Microsoft/TypeScriptSamples)

## 手册指南

### 基础类型

TS支持与JS几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。

#### 布尔值

```javascript
let isDone: boolean = false;
```

#### 数字

```javascript
let decLiteral: number = 6; // 十进制
let hexLiteral: number = 0xf00d; // 十六进制
let binaryLiteral: number = 0b1001; // 二进制
let octalLiteral: nuber = 0o733; // 八进制
```

#### 字符串

```javascript
let name: string = 'tony'; // 普通字符串
let name: string = `my name is ${myname}`;// 模板字符串
```

#### 数组

```typescript
// 元素类型后面接上[]，表示由此元素组成的一个数组
let list: number[] = [1, 2, 3];
// 使用数组泛型，Array<元素类型>
let list: Array<number> = [1, 2, 3];
```

#### 元组 Tuple

元组类型表示一个已知元素数量和类型的数组，各个元素的类型不必相同。如果数组内的元素和定义的数量类型不同，会报错。

```typescript
let x: [string, number] = ['i', 12];

x = [1, 'e']; // Error
```

当访问一个一直索引的元素，正确

```typescript
x[0].substr(); // OK
x[1].substr(); // Error, 'number' does not have 'substr'
```

当访问一个越界的元素，会使用联合类型替代。

```typescript
x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString

x[6] = true; // Error, 布尔不是(string | number)类型
```

#### 枚举

```typescript
// Red Green Blue是名字，值是0,1,2
enum Color {Red, Green, Blue}
let r: Color = Color.Red;

// 可以手动指定成员的值，也可以全部都采用手动赋值
enum Color2 {Red=1, Green, Blue}

// 可以由枚举的值得到它的名字，也可以由名字得到枚举的值
enum Color3 {Red=1, Green=1, Blue=1}
console.log(Color2[1]);
```

```typescript
enum Color {
  Red, Green, Blue
}
{0: "Red", 1: "Green", 2: "Blue", Red: 0, Green: 1, Blue: 2} 


enum Color2 {
  Red = 1, Green, Blue
}
{1: "Red", 2: "Green", 3: "Blue", Red: 1, Green: 2, Blue: 3} 


enum Color3 {
  Red, Green = 2, Blue
}
{0: "Red", 2: "Green", 3: "Blue", Red: 0, Green: 2, Blue: 3} 


enum Color4 {
  Red, Green = '', Blue = ''
}
{0: "Red", Red: 0, Green: "", Blue: ""}

enum Color5 {
  Red, Green = '0', Blue = ''
}
{0: "Red", Red: 0, Green: "0", Blue: ""} 

enum Color6 {Red=1, Green=1, Blue=1}
{1: "Blue", Red: 1, Green: 1, Blue: 1}
```

#### Any

any类型允许你在编译时可选择地包含或移除类型检查。Object类型的变量允许赋任何值，但是不能调用任意的方法，即使真的有这种方法。

```typescript
let noSure: any = 4;
notSure.ifItExists();

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesnot exist on type 'Object'
```

#### Void

```typescript
// 没有任何类型
function warnUser(): void {
    
}
// 声明void类型的变量，只能赋予undefined和null
let user: void = null;
```

#### Null和Undefined

```typescript
null和undefined类型只能赋值给本身
默认情况下null和undefined时所有类型的子类型，如：可以把null和undefined复制给number类型的变量
当指定了--strictNullChecks，undefined和null只能赋值给void和本身。
```

#### Never

`never`类型表示的是那些永不存在的值的类型。 例如， `never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never`类型，当它们被永不为真的类型保护所约束时。

`never`类型是任何类型的子类型，也可以赋值给任何类型；然而，*没有*类型是`never`的子类型或可以赋值给`never`类型（除了`never`本身之外）。 即使 `any`也不可以赋值给`never`。

下面是一些返回`never`类型的函数：

```ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
```

#### Object

`object`表示非原始类型，也就是除`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型。

使用`object`类型，就可以更好的表示像`Object.create`这样的API。例如：

```ts
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

#### 类型断言

只在编译阶段起作用

```typescript
let strlen: number = (<string>someValue).length;

let strlen: number = (someValue as string).length;
```



#### let

### 变量声明

#### 变量声明

使用let和const代替var

#### 解构



### 接口

```typescript
// 必须包含一个label属性且值为string
interface LabelledValue {
    color?: string; // 可选属性
    label: string;
} // 代表了一个有一个label属性且类型为string的对象

function printLabel(labelObj: LabelledValue) {
    console.log(labelledObj.label);
}

let myObj = { size: 10, label: 'size 10 Obj' };
printLabel(myObj);
```

#### 可选属性

带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个`?`符号。

可以对可能存在的属性进行预定义，可以捕获引用了不存在的属性时的错误。 比如，我们故意将 `createSquare`里的`color`属性名拼错，就会得到一个错误提示：

```ts
interface SquareConfig {
  color: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = {color: "white", area: 100};
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: "black"});
```

#### 只读属性

一些对象属性只能在对象刚刚创建时修改其值。

```typescript
interface Point {
    readonly x: number;
    readonly y: number;
}

let p1: Point = { x: 10, y: 10 };
p1.x = 10; // error 哪怕值实际并没有改变
```

TypeScript具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法都去掉了，保证数组创建后不再被修改。

```typescript
let a: number[] = [1];
let ro: ReadonlyArray<number> = a;
let ro2: ReadonlyArray<number> = a;
ro[0] = 1; // error: only permit reading
ro.push(1); // error: property 'push' doesnot exist
ro.length = 100 // error: a constant or read-only property
a = ro; // type ReadonlyArray<number> is not assignable to number[], property 'pop' is missing on type ReadonlyArray<number> 
ro2 = ro; // OK
```

可以使用类型断言重写，实现把ReadonlyArray重写到普通数组

```typescript
a = ro as number[];
```

readonly用作属性，const用作变量

#### 额外的属性检查

我们在第一个例子里使用了接口，TypeScript让我们传入`{ size: number; label: string; }`到仅期望得到`{ label: string; }`的函数里。                     我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。

然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿                     `createSquare`例子来说：

```

interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
```

注意传入`createSquare`的参数拼写为*colour*而不是`color`。 在JavaScript里，这会默默地失败。                 

你可能会争辩这个程序已经正确地类型化了，因为`width`属性是兼容的，不存在`color`属性，而且额外的`colour`属性是无意义的。

然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过                     *额外属性检查*，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。                 

```

// error: 'colour' not expected in type 'SquareConfig'
let mySquare = createSquare({ colour: "red", width: 100 });
```

绕开这些检查非常简单。 最简便的方法是使用类型断言：                 

```

let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 `SquareConfig`带有上面定义的类型的`color`和`width`属性，并且*还会*带有任意数量的其它属性，那么我们可以这样定义它：

```

interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig`可以有任意数量的属性，并且只要它们不是`color`和`width`，那么就无所谓它们的类型是什么。

还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为                     `squareOptions`不会经过额外属性检查，所以编译器不会报错。

```

let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。  对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。  就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。                     在这里，如果支持传入                     `color`或`colour`属性到`createSquare`，你应该修改`SquareConfig`定义来体现出这一点。

#### 函数类型

接口可以描述带有属性的普通对象，也可以描述函数类型。

使用接口表示函数类型，需要给接口定义一个调用签名：

- 只有参数列表和返回值类型的函数定义
- 参数列表里每个参数都需要名字和类型

```typescript
interface SearchFunc {
    (source: string, subString: string): boolean;
}
```

这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。                 

```typescript
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}
```

对于函数的类型检查来说，函数的参数名不需要与接口定义的名字相匹配。函数的参数进行逐个检查时，对应位置上的参数类型应当兼容。如果不指定参数类型，typescript的类型系统会推断出参数类型。

```typescript
let myFunc: SearchFunc;
myFunc = function(src: string, sub: string): boolean {
    return src.search(sub);
}
```

#### 可索引的类型

接口可以描述能够“通过索引”得到的类型。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值的类型。

描述数组：

```typescript
interface StringArray {
    [index: number]: string;
}

let myArray: stringArray;
myArray = ['bob', 'fred'];

let myStr: string = myArray[0];
```

支持的索引签名类型：字符串和数字。

TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用                     `number`来索引时，JavaScript会将它转换成`string`然后再去索引对象。 也就是说用                     `100`（一个`number`）去索引等同于使用`"100"`（一个`string`）去索引，因此两者需要保持一致。

```typescript

class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
```

字符串索引签名能够很好的描述`dictionary`模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了                     `obj.property`和`obj["property"]`两种形式都可以。 下面的例子里，                     `name`的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：

```typescript

interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
```

最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：

```typescript

interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!
```

你不能设置`myArray[2]`，因为索引签名是只读的。



#### 类类型

##### 实现接口

Typescript可以用接口来实现让一个类去符合某种约定。



接口描述的是类的公共部分，而不是公共和私有两部分。它不会帮你检查类是否具有某些私有成员。

```typescript
interface ClockInterface {
    currentTime: Date;
	setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor() {}
}
```































































